/*
Debouncing and throttling are two techniques used in web development to control how often a function is executed, particularly in response to events like scrolling, resizing, or keystrokes. While they both aim to improve performance and manage event handling, they serve slightly different purposes:

### Debouncing

- **Purpose**: Ensure that a function is not executed until after a certain amount of time has passed since the last time it was invoked.
- **Implementation**: Reset a timer every time the function is called. If the timer expires (no new calls have been made within the specified time period), then the function is executed.
- **Use Cases**: Useful for scenarios where you want to wait for a user to finish an action before taking an action (e.g., waiting for a user to stop typing before performing a search).
*/

function debounce(func, delay) {
  let timeoutId;

  return function() {
    const context = this;
    const args = arguments;

    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(context, args);
    }, delay);
  };
}

const debouncedFunction = debounce(() => {
  console.log('Debounced function executed');
}, 300);

inputElement.addEventListener('input', debouncedFunction);

/*
Throttling

- **Purpose**: Limit the rate at which a function can be executed, ensuring it does not execute more than once in a specified time interval.
- **Implementation**: Invoke the function at most once per specified interval, ignoring subsequent calls until that interval has elapsed.
- **Use Cases**: Useful for scenarios where you want to ensure that a function is not called more frequently than a certain rate (e.g., limiting the rate of API calls or scroll event handling).
*/

function throttle(func, delay) {
  let isThrottled = false;

  return function() {
    const context = this;
    const args = arguments;

    if (!isThrottled) {
      func.apply(context, args);
      isThrottled = true;
      setTimeout(() => {
        isThrottled = false;
      }, delay);
    }
  };
}

const throttledFunction = throttle(() => {
  console.log('Throttled function executed');
}, 300);

inputElement.addEventListener('input', throttledFunction);
/*
### Key Differences

- **Execution Behavior**: 
  - **Debouncing** delays the execution of a function until after a specified time has passed since the last function call.
  - **Throttling** limits the rate at which a function can be executed to a specified time interval, ensuring it does not execute more frequently than that interval.

- **Use Cases**:
  - Use **debouncing** when you want to wait for a pause in events (e.g., typing) before triggering an action.
  - Use **throttling** when you want to limit the frequency of execution of a function to improve performance or control API usage.

Both techniques are essential for optimizing performance in applications where frequent event triggering could lead to inefficiencies or overwhelm system resources. 

Choosing between debouncing and throttling depends on the specific use case and the behavior you want to achieve in your application:

### When to Use Debouncing

Use debouncing when:

- **User Input Delay**: You want to wait for a pause in user input (e.g., typing, scrolling) before triggering an action. 
    For example, implementing a search-as-you-type feature where you only want to perform the search after the user has stopped typing for a short period.
  
- **Event Handling**: You need to handle events that may fire rapidly in a short time frame, but you only care about the final state after a delay.

### When to Use Throttling

Use throttling when:

- **Rate Limiting**: You want to limit the rate at which a function can be executed to improve performance or prevent excessive resource consumption. 
    For example, throttling API calls to a server to ensure they do not exceed a certain rate per second.

- **Scrolling and Resize Events**: You want to limit the frequency of executing code in response to events like scrolling or window resizing to reduce the frequency of calculations 
    or DOM manipulations.

### Which is Better?

There isn't a definitive answer to which is better because it depends on the specific requirements of your application:

- **Debouncing** is typically used when you want to respond to a user's final action after they have stopped interacting with a UI element for a brief period. 
    It ensures that a function is only executed after a specified quiet period, which can be beneficial for scenarios like auto-suggestions in search bars.

- **Throttling** is more suitable when you want to ensure that a function is not called more frequently than a certain rate, regardless of how many times an event fires. 
    It's useful for limiting the execution rate of intensive tasks or for controlling interactions with external services.

### Considerations for Implementation

- **Performance**: Debouncing may delay the execution of a function until after a specified timeout, which can be beneficial for reducing unnecessary computations or network requests. Throttling, on the other hand, limits the frequency of function calls, which can help prevent performance bottlenecks.

- **User Experience**: Debouncing can improve user experience by preventing rapid, potentially distracting changes or actions in response to user input. 
    Throttling can provide a smoother experience by ensuring that UI updates or interactions occur at a consistent rate.

*/